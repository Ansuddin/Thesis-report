
This chapter builds the foundation for the thesis introducing relevant concepts and disciplines for the thesis. 


Section \ref{evaluationofmatrix} provides an evaluation of the Matrix security model. The security model is evaluated in the context of a secure messaging system.  
The paper \emph{SoK: Secure Messaging} describes a evaluation framework for evaluating secure messaging systems. They define several security properties related to such systems \cite{sok} which will be presented.


All secure messaging systems with end-to-end encryption are based on the Double Ratchet algorithm from the Signal Protocol which will also be described.


Finally the architecture of Matrix and concepts related to Information-Flow Control will be introduced.

\section{Information security}

Information security is the discipline of protecting information. The key principles in information security are expressed through the CIA model. For a system to be secure these principles should be guaranteed \cite{michael2012}.

\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{figures/cia.png}
	\caption{CIA triad}
	\label{fig:CIA triad}
\end{figure}


\subparagraph{Confidentiality}
Confidentiality is keeping information secret from unauthorized people. This is a major goal in information security. Encryption and access control are common ways of ensuring confidentiality \cite{michael2012}.

In a secure messaging system confidentiality would be guaranteed if the message being sent is only readable by the recipient and no one else \cite{sok}.

\subparagraph{Integrity}
Integrity is providing that information is unaltered and can only be changed by authorized people. If information is intercepted and changed during transit it would be a violation of integrity \cite{michael2012}.  
More specifically for a secure messaging it would mean that no altered message is accepted by the recipient \cite{sok}.

\subparagraph{Availability}
Making sure that information is accessible to authorized people is the goal of availability. Denial of Service attack \footnote{https://en.wikipedia.org/wiki/Denial-of-service\_attack} are common attacks targeting availability. 

Availability is generally more related to the system being available where the information itself plays a minor role \cite{michael2012}.
\\
\\
Depending on the type of system other properties must be satisfied as well. 


\subsection{Security properties}
The goal in a secure messaging system is to protect the messages being sent. The following properties are related to protecting messages.


\subparagraph{Authentication}
When a message is received the participant can verify that the message was sent from the actual sender. Furthermore a participant will receive evidence from a participant in a conversation that hey hold a known long-term secret. 



\subparagraph{Perfect Forward Secrecy}
If all keys are compromised than the decryption of any previously sent message should not be possible. Hence all previous messages would be secure however all future messages would be insecure 

\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{figures/forwardsecrecy.png}
	\caption{Forward secrecy}
	\label{fig:forward}
\end{figure}

\subparagraph{Backward secrecy}
If all keys are compromised than the decryption of \emph{future} messages should be possible. This property also goes by the names \emph{future secrecy} and \emph{post compromise security}. 

\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{figures/backwardsecrecy.png}
	\caption{Backward secrecy}
	\label{fig:backward}
\end{figure}


\subsubsection{Other security properties}


\subparagraph{Participant Consistency} 
Whenever a message is accepted by a participant all participants are guaranteed to have identical view of the participant list.

\subparagraph{Destination Validation}
When a participant receives a message it can be verified that the participant was the intended recipient.

\subparagraph{Anonymity Preserving} 
The anonymity of the participants should be preserved and not linking any key identifiers.

\subparagraph{Speaker Consistency} 
There is consensus among the participants on the sequence of messages they receive by each participant. There might be a mechanism for checking consistency whenever a message is sent or after it has been received.

\subparagraph{Causality Preserving}
Messages must not be displayed before the message that originally precedes it has been displayed.

\subparagraph{Global Transcript} 
A global order where all messages are viewed in the same order for all participants.

\subparagraph{Deniability}
Deniability is a property where other participants cannot confirm that the message being sent was from the sender. Yet during the conversation there will be assurance for the recipient that the message being sent was authentic and sent by the sender \cite{sok}.

\begin{itemize}
	\item \emph{Message Unlinkability:} A deniability property that gives no guarantees that if a participant sent a message that other messages was sent by that participant as well. 
	\item \emph{Message Repudiation:} It can not be proved that a message was authored by a participant given the conversation transcript and all cryptographic key material. 
	\item \emph{Participant Repudiation:} It can not be proved that a participant was in a group conversation without his conversation transcript and cryptographic key material. 
\end{itemize}

The following properties are also defined in the paper \emph{SoK: Secure Messaging} but are less relevant for security.

\subparagraph{Group}

\begin{itemize}
	\item \emph{Computational Equality:} The computational load is equal for all participants.
	\item \emph{Trust Equality:} There is equal trust among all participants. 
	\item \emph{Subgroup messaging:} In the same conversation a participant can send messages to a subset of the participants.
	\item \emph{Contractible Membership:} When a participant leaves a conversation the protocol does not need to restart.
	\item \emph{Expandable Membership:} When a participant joins a conversation the protocol does not need to restart.
\end{itemize}

\subparagraph{Adoption}

\begin{itemize}
	\item \emph{Out-of-Order Resilient:} Messages received out-of-order should be accessible when received.
	\item \emph{Dropped Message Resilient:} On a unreliable network messages might be dropped in transit however it should not prevent decryption of future messages.
	\item \emph{Asynchronous:} Messages can be sent securely to recipients while they are offline.
	\item \emph{Multi-Device Support:} A participant can have multiple devices in a conversation and each device must be synchronized and should have the same historical conversation view
	\item \emph{No Additional Service:} There is no requirement of additional infrastructure being setup other than the participants. 
\end{itemize}





\newpage

\subsection{Concepts}

\subsubsection{Diffie-Hellman Key Exchange}

Diffie-Hellman is a key exchange protocol to establish a shared secret over an insecure channel. Public information is send over an insecure and using asymmetric keys two parties can derive the same shared key.


The first step is to agree on some public values. Either of the parties start the protocol by picking a large prime \emph{p} and a integer \emph{g} then the values are sent over the insecure channel.  

\begin{figure}[H]
	\hspace*{-1cm} 
	\centering
	\includegraphics[width=14cm]{figures/dh.png}
	\caption{Simple Diffie-Hellman Key Exchange}
	\label{fig:dh}
\end{figure}

Alice and Bob will each pick a private key value and compute a public key value. The computed key value is sent over the insecure channel and Alice and Bob will both perform the same computation as previously \cite{crypto101}.


The Diffie-Hellman is vulnerable to man in the middle attack since there is no authentication taking place. There exist a solution to this problem using asymmetric key pairs and signing the messages being sent \cite{crypto101}.

\subsubsection{Key Derivation function}

Assume a secret key is established between two parties and is used to encrypt messages and exchange them over an insecure channel. An adversary listening might store all the messages being send even though he is not able to read them. However at some point he manages to compromise the secret key hence being able to decrypting every message ever sent.

To overcome the above scenario ephemeral keys are used. Such keys are short lived and are discarded after use.   

New secret keys can be generated using a \emph{Key Derivation Function} (KDF).
A KDF is a one way function that derives one or more randomized secret keys based on a secret key (or multuple) and optionally some input value \cite{crypto101}. Figure \ref{fig:kdf} illustrates this.

 \begin{figure}[H] 
 	\centering
 	\includegraphics[width=8cm]{figures/kdf.png}
 	\caption{Key derivation function}
 	\label{fig:kdf}
 \end{figure}


A core concept in the Double Ratchet algorithm is KDF chains which build a chain of secret keys using KDF \cite{doubleratchet}. 


\subsubsection{Signal Protocol}

The Signal Protocol provides end-to-end encryption and was developed in 2013 and was first introduced in the app TextSecure\footnote{https://en.wikipedia.org/wiki/TextSecure}.

The Signal Protocol consists of two parts; The \emph{Triple Diffie-Hellman protocol} (TripleDH) and the Double Ratchet algorithm.

\paragraph{Triple Diffie-Hellman protocol}\label{tripledh}
Before the Double Ratchet algorithm can be used the two parties communicating need to agree on a shared secret key. In the Signal protocol this is achieved with Triple Diffie-Hellman protocol \emph{(TripleDH)}.

The Triple Diffie-Hellman protocol is a \emph{key agreement protocol}. It involves a server and two parties; Alice and Bob. 

The TripleDH protocol is characterized by three phases:

\begin{enumerate}
	\item \emph{Publishing keys:} A identity key and several prekeys belonging to Bob is published by him to a server.
	\item \emph{Sending initial message:} Alice sends an initial message to Bob. A prekey bundle is obtained by Alice from the server in order to send an initial message to Bob.
	\item \emph{Receiving initial message:} Alice's message is received and processed by Bob.
\end{enumerate}

\subparagraph{Publishing keys}
Bob needs to register a \emph{prekey bundle} to the server if he wants Alice to be able to send him messages. Alice will likewise have registered a prekey bundle so anyone can to anyone wants to start a message conversation with her.  
The prekey bundle exists of:

\begin{itemize}
	\item Identity key \emph{IK\textsubscript{B}}. This key is only published once by Bob.
	\item Signed prekey \emph{SPK\textsubscript{B}}. This key is reuploaded again after some period of time (eg. after each week or each month). 
	\item Prekey signature \emph{Sig(IK\textsubscript{B}, Encode(SPK\textsubscript{B}))}. This key is also reuploaded again like the signed prekey.
	\item Set of one-time prekeys \emph{(OPK\textsubscript{B}\textsuperscript{1}, OPK\textsubscript{B}\textsuperscript{2}, OPK\textsubscript{B}\textsuperscript{3}, ...)}. These keys are uploaded by Bob occasionally. Bob is informed by the server when there are few one-time prekeys left. 
	
	To ensure forward secrecy the private key of the one-time prekeys are deleted once Bob received messages that uses them. The signed prekey is deleted as well. However Bob might hold on to it for some time to get the messages that was delayed.  
\end{itemize}

\subparagraph{Sending initial message}
Alice retrieves Bobs public keys from the server. She receives one of Bob's single one-time prekey. The server deletes the one-time prekey that was send. It might be the case that all the one-time prekeys at the server has been used \cite{tripledh}.  


Alice verifies the prekey signature if the verification fails the protocol is aborted or else the following public keys are provided to generate a shared secret:

\begin{itemize}
	\item Identity key \emph{IK\textsubscript{A}}. Her own identity key. 
	\item Ephemeral key \emph{EK\textsubscript{A}}. The public key from a generated ephemeral key pair.
\end{itemize}


To generate the shared secret the following calculations are made:

\[DH_1 = DH(IK_A, SPK_B)\]
\[DH_2 = DH(EK_A, IK_B) \]
\[DH_3 = DH(EK_A, SPK_B)\]
\[DH_4 = DH(EK_A, OPK_B)\]
\[SK = KDF(DH_1 || DH_2 || DH_3 || DH_4)\]

There are performed atleast three Diffie-Hellman where \emph{DH\textsubscript{4}} is optional depending on if the server had more one-time prekeys.

Authentication is provided by \emph{DH\textsubscript{1}} and \emph{DH\textsubscript{2}} while \emph{DH\textsubscript{3}} and \emph{DH\textsubscript{4}} provides forward secrecy.

The figure \ref{tripledh} illustrates the calculations. 


\begin{figure}[H]
	\centering
	\includegraphics{figures/tripledh.png}
	\caption{Calculations of DH1-DH4 \cite{tripledh}.}
	\label{fig:tripledh}
\end{figure}

Alice then deletes the DH values and her private key associated to the ephemeral key to uphold forward secrecy and sends the initial message to Bob which consists of \cite{tripledh}: 

\begin{itemize}
	\item Cypher text with AEAD encryption  \footnote{https://en.wikipedia.org/wiki/Authenticated\_encryption} with \emph{associated data} using her own and Bob's identity keys.
	\item Her identity key \emph{IK\textsubscript{A}}.
	\item Her ephemeral key \emph{EK\textsubscript{A}}.
	\item Some identifiers to which of Bob's prekeys she used.
	
\end{itemize} 


\subparagraph{Receiving initial message}

When Bob receives Alice's initial message he performs the exact same calculations in phase two and derives the same shared secret key \emph{SK}.

Bob then decrypts the cypher text with the shared key and \emph{associated data} using his own and Alice's identity keys. If the decryption fails the protocol is aborted and \emph{SK} is deleted. Otherwise the protocol is complete and Bob deletes the one-time private prekey. 
The shared secret key can then be used for the Double Ratchet algorithm \cite{tripledh}.  

\paragraph{Double Ratchet algorithm}

After a shared secret key has been established the Double Ratchet algorithm can then be used to send and receive encrypted messages.

Each party has three chains; root chain, sender chain and receive chain. The chains are KDF chains and will take two keys as input (a KDF chain key and some other input key) and output new two keys (a new KDF chain key and some other output key). The KDF chain is illustrated in figure \ref{symkeyratchet}.

The algorithm has a \emph{Diffie-Hellman ratchet} step and \emph{symmetric ratchet} step and the chains are used across both steps.

\begin{itemize}
	\item \emph{Diffie-Hellman ratchet:} The parties exchanges new Diffie-Hellman public keys with the messages being sent. New secrets are then derived using Diffie-Hellman (DH). The secret that DH outputs is used as input to the root chain. The root chain then output new chain keys for the receiving and sending chains. 
	
	\item \emph{Symmetric ratchet:} The sending and receiving chains uses the chain keys derived from the root chain and for each message sent and received the chains are advanced. The output from the receiving and sending chains are keys for encrypting or decrypting messages. 
\end{itemize}


\subparagraph{Symmetric ratchet}
The symmetric ratchet provides message key through the receiving and sending chains. A message key is used for encryption or decryption of a message.

In the symmetric ratchet a single ratchet step is the calculation of the next key chain and message key. The inputs are the current chain key and a constant. Figure \ref{fig:symkeyratchet} illustrates two steps in a symmetric ratchet.

\emph{Forward secrecy} is provided since KDF is a one-way function and it is not possible to go backward and get the input chain key from the output chain key. However since the other input is simply a constant all future keys chain keys and message keys can be derived from an older chain key more specifically there is lack of backward secrecy.


\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{figures/symmetrickeyratchet.png}
	\caption{Symmetric key ratchet \cite{doubleratchet}.}
	\label{fig:symkeyratchet}
\end{figure}


\newpage
\subparagraph{Diffie-Hellman ratchet}

Double ratchet provides backward secrecy by comining the Symmetric ratchet with a Diffie-Hellman ratchet hence the name \emph{Double Ratchet}.

Every message from either party begins with a header which contains the sender's current ratchet public key. Whenever a new ratchet public key is received a new ratchet key pair is generated; a secret is derived through Diffie-Hellman with the input being the received ratchet public key and the ratchet private key from the new generated key pair.

Alice starts a conversation with Bob and uses his published public key as a ratchet public key. Alice then generates a new ratchet key pair and derives a shared secret key using Diffie-Hellman and would that as input to her \emph{sending chain}. Alice then sends her new ratchet public key to Bob. At the receiving end Bob derives the same shared secret which would be the input to his \emph{receiving chain}. Alice's sending chain and Bob's receiving chain share the same secret hence he can derive the message key and decrypt the message sent from Alice. When Bob sends a reply to Alice he would generate a new ratchet key pair and derive a new secret which would be input to his \emph{sending chain}.

Figure \ref{fig:dhratchet1} shows an ongoing message exchange with new secrets being derived and the sending and receiving chains being advanced.

\begin{figure}[H]
	\centering
	\includegraphics[width=9cm]{figures/dhratchet5.png}
	\caption{Diffie-Hellman ratchet \cite{doubleratchet}.}
	\label{fig:dhratchet1}
\end{figure}


When Alice receive the reply from Bob she would perform the exact same steps. This ultimately results in a continous loop of generating new ratchet key pairs and using Diffie-Hellman to derive the same shared secret key. A continuation is shown in figure \ref{fig:dhratchet2}

\begin{figure}[H]
	\centering
	\includegraphics[width=9cm]{figures/dhratchet6.png}
	\caption{Continuation of Diffie-Hellman ratchet  \cite{doubleratchet}.}
	\label{fig:dhratchet2}
\end{figure}


As mentioned in the beginning of the Double Ratchet section the Diffie-Hellman ratchet does have a root chain which would provide inputs to the sending and receiving chains. A more correct view of the process in Diffie-Hellman is shown in figure \ref{fig:dhratchetcon}. 


\begin{figure}[H]
	\centering
	\includegraphics[width=9cm]{figures/dhratchet7.png}
	\caption{Diffie-Hellman ratchet 7 \cite{doubleratchet}.}
	\label{fig:dhratchetcon}
\end{figure}

\paragraph{Double ratchet}

When combining Diffie-Hellman ratchet and symmetric-key ratchet the result is the Double ratchet.

\begin{itemize}
	\item When sending or receiving a message the corresponding message key is derived by performing a symmetric-key ratchet step.
	\item Upon receiving a new ratchet public key the Diffie-Hellman ratchet step performed right before the symmetric-key ratchet step with the goal of replacing old chain keys with new ones.  
\end{itemize}

Assume that the message exchanged is a continuation from the TripleDH key exchange described in section \ref{tripledh}. Alice had sent an initial message. The initial ratchet public key would be Bob's signed prekey \emph{SPK\textsubscript{B}} and the new ratchet key pair would be the Alice's ephemeral key pair that she generated. Alice calculated a shared secret which is the \emph{root key}. She then generates a new ratchet key pair and takes the output from Diffie-Hellman and use it as input for the \emph{root chain}. The root chain then outputs a new root key \emph{RK} and a sending chain key {CK}.

The figure \ref{doubleratchet1} depicts this with a view of Alice's chains.


\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{figures/doubleratchet1.png}
	\caption{Double ratchet 1 \cite{doubleratchet}.}
	\label{fig:doubleratchet1}
\end{figure}

When Alice then sends a message \emph{A1} the symmetric-key ratchet step will return a new chain key and a message key. The message can then be encrypted with the message key.

\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{figures/doubleratchet2.png}
	\caption{Double ratchet 2 \cite{doubleratchet}.}
	\label{fig:doubleratchet2}
\end{figure}

Next Alice receives a message \emph{B1} from Bob. The message header contains a new ratchet public key and a Diffie-Hellman ratchet step is performed. New sending and receiving chain keys are derived and followed by a symmetric-key ratchet step to derive the receiving message key to decrypt the message.

\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{figures/doubleratchet3.png}
	\caption{Double ratchet 3 \cite{doubleratchet}.}
	\label{fig:doubleratchet3}
\end{figure}


\newpage
\section{Matrix}

Matrix is an open standard protocol for messaging over HTTP and synchronizing data. Matrix provides secure real-time communication over a decentralized federated network with eventual consistency. Matrix cover use cases such as instant messaging, VoIP, Internet of Things communication and is generally applicable anywhere for subscribing and publishing data over standard HTTP API.

%Any kind of json can be published to a room \cite{matrixvideoiot}.
% 3:10


% https://www.youtube.com/watch?v=-ofZMnKkp_Y 5:00 , 18:30

\subsection{How does it work?}

Matrix defines a conceptual place \emph{room} where data can be published and subscribed to. A room is shared and replicated among multiple \emph{homeservers}. The example shown in figure \ref{fig:matrix1} is a conversation in a room between three clients on different homeservers. 

In the example Alice starts by sending a message to the room. When Alice sends a message it is send to her homeserver. Each homeserver stores messages in a \emph{directed acyclic graph} called an \emph{event graph}. The message send by Alice is added to the event graph and is linked to most recent message(s) in the graph. The message is then signed with the signtatures of all previous messages by Alice's homeserver in order to make it tamper-proof. Finally the homeserver relays the message to the Bob's and Charlie's homeservers.

Upon receiving the message the other homeservers validates the message and then adds it to their own event graph. The message now persists in Bob's and Charlie's servers and can be retrieved from Bob's and Charlie's clients.

\begin{figure}[H]
	\centering
	\includegraphics[width=9cm]{figures/matrix1.png}
	\caption{ Matrix \cite{matrixhome}.}
	\label{fig:matrix1}
\end{figure}

Bob replies to Alice's message and is first send to the homeserver and linked to Alice's message in the event graph. At the same time Charlie also send a reply and an inconsistency occurs as depicted in figure \ref{fig:matrix2}.


\begin{figure}[H]
	\centering
	\includegraphics[width=9cm]{figures/matrix2.png}
	\caption{ Matrix \cite{matrixhome}.}
	\label{fig:matrix2}
\end{figure}


Bob's message arrives first to Alice and Charlie's homeservers. Alice adds the message to her own event graph and has a view that is consistent with Bob's. Charlie adds the message to the event graph; Bob's message precedes Alice's message hence message 2 and 3 are linked to message 1 shown in figure \ref{fig:matrix3};


\begin{figure}[H]
	\centering
	\includegraphics[width=9cm]{figures/matrix3.png}
	\caption{ Matrix \cite{matrixhome}.}
	\label{fig:matrix3}
\end{figure}

 
The other homeservers then receive Charlie's message and is added to their event graph. The room is yet again in sync and all the homeservers have a consistent view of the room.


\begin{figure}[H]
	\centering
	\includegraphics[width=9cm]{figures/matrix4.png}
	\caption{ Matrix \cite{matrixhome}.}
	\label{fig:matrix4}
\end{figure}

Alice sends a new message and is linked to the most recent unlinked objects (both Bob's and Charlie's). The message is then relayed to the other homeservers. The split in the event graph is merged. This example also shows how Matrix provides eventual consistency.

\begin{figure}[H]
	\centering
	\includegraphics[width=9cm]{figures/matrix5.png}
	\caption{ Matrix \cite{matrixhome}.}
	\label{fig:matrix5}
\end{figure}

%In the example above the message is represnted by a JSON object and could be of any kind of object.


\subsection{Architecture}
The previous section introduced the notion of a\emph{room} which clients sends messages to. The messages being in Matrix are actually JSON objects called \emph{events}. The events can be of any kind of structure hence it is not limited to messaging. Events are stored at homeservers and the communication history for a room is modelled using \emph{directed acyclic graph} called\emph{event graphs}. Matrix provides a specification for Client-Server API which is used for sending and synchronizing events between the client and its belonging homeserver. Matrix also provides specification for a Server-Server API which synchronizes data among homeservers with eventual consistency. The synchronization process between homeservers is defined by the term \emph{Federation} \cite{matrixspec}. 


\begin{figure}[H]
	\centering
	\includegraphics[width=11cm]{figures/matrix_architecture.png}
	\caption{ Matrix conceptual architecture \cite{matrixspec}.}
	\label{fig:matrix_architecture}
\end{figure}


As previously mentioned a room is a conceptual place for sending and receiving events. Each room is uniquely identified by a \emph{Room ID}. The figure \ref{fig:matrix_room} shows how events are send and received from a room.



\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{figures/matrix_room.png}
	\caption{ Matrix conceptual architecture \cite{matrixspec}.}
	\label{fig:matrix_room}
\end{figure}

\subsubsection{Event}

Every data exchange in Matrix is an event. Events are used to express state changes in a room as well as messages being sent. An event has a type used to differ between what kind of event is being sent and what kind of data it might hold. Matrix comes with reserved name spaces; \emph{m.room.message} is a type for instant messaging. The following is an example of a event of type \emph{m.room.message} \cite{matrixspec}.


\begin{lstlisting}[style=json]
{
	"content": {
		"body": "Hello world!",
		"msgtype": "m.text"
	},
	"room_id": "!wfgy43Sg4a:matrix.org",
	"sender": "@bob:matrix.org",
	"event_id": "$asfDuShaf7Gafaw:matrix.org",
	"type": "m.room.message"
}
\end{lstlisting}

The specification is open for defining custom types which can express any kind of data one might want to exchange \cite{typeofevent}.


\subsection{Matrix specification}
Matrix has two main API specifications; Client/Server API and Federated API. Any Matrix SDK implements the API defined at the Client/Server API specification. If a custom homeserver was to be developed from scratch it would have to conform to the Federated API to be able to be a part of Matrix. 

\subparagraph{Client/Server API}
For clients to send and receive messages the Client/Server API is used. The API mainly provides specification for:

\begin{itemize}
	\item Sending and receiving messages
	\item Configure rooms
	\item Synchronize historical conversation
\end{itemize}

 There exist several SDKs implementing the API.  

\subsection{End-to-end Encryption}
Security is a high priority for Matrix design. Especially with the decentralized architecture with data being replicated over a federation federation of servers. Matrix provides security guarantees through end-to-end encryption using Olm and Megolm cryptographic ratchet. Olm is based on the Double Ratchet algorithm and Megolm is an extension for secure group communication. Olm and Megolm are examined in section \ref{matrixeval}.



\newpage
\section{Information Flow Control} %mere konkret og teknisk
%Selvom jeg ikke kiggr på fx trafic analysis så er det vigtigt at nævne og påpege det ikkeer noget jeg løser
In the beginning of this chapter the security properties confidentiality and integrity were mentioned which are major security goals for a system. If there is \emph{secure information flow} throughout the system then confidentiality and integrity is achieved \cite{Hedin2011}. Secure information flow means that only authorized flow of information is allowed \cite{Denning1976}. There are two aspects to secure information flow; the reading of the information (confidentiality) and the writing of the information (integrity) \cite{Hedin2011}. 

\emph{Information Flow Control} is a \emph{security mechanism}\footnote{"A security mechanism is a method, tool, or procedure for enforcing a security policy" \cite{Bishop2004}} for achieving secure information flow.
Information Flow Control is a language-based security technique that can enforce defined \emph{security policies}\footnote{"A security policy is a statement of what is, and what is not, allowed." \cite{Bishop2004}} concerning confidentiality and integrity of data. It enables us to express where information may flow to and under what conditions. 

\subsection{Lattice model}\label{lattice}

By classifying information with \emph{security levels} we can express where information may flow. Consider the following confidentiality policy; we classify \emph{secret} as secret information, and classify \emph{public} as public information. For the two secuirty levels it holds that flow from public to public is allowed, public to secret is allowed, and secret to secret is allowed. For preserving confidentiality flow from secret to public is under no circumstances allowed.  This can be expressed as \emph{public $\leq$ secret} and gives us a simple lattice\footnote{https://en.wikipedia.org/wiki/Lattice\_(order)} structure where information flows upwards shown in figure \ref{fig:lattice}a \cite{Smith}.


\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{figures/lattice.png}
	\caption{ Lattice model for confidentiality and integrity \cite{Musard2014}}
	\label{fig:lattice}
\end{figure}

Likewise a policy for integrity can be specified where information from an \emph{untrusted} source must not flow to information with a security level of \emph{trusted} which is somewhat opposite of the confidentiality policy. Figure \ref{fig:lattice}b illustrates an integrity lattice. By combining the two we get a more complex lattice show in figure \ref{fig:lattice}c.

\subsection{Explicit and implicit flow}\label{explicitimplicit}
The problem with mainstream programming languages is that they are unable to enforce defined policies such as the confidentiality and integrity policies described in the previous section. Consider the following flow:

\begin{lstlisting}
	public = secret;
\end{lstlisting}

This is an \emph{explicit flow} and is where the \emph{secret} value is directly copied into the \emph{public} value which obviously is a violation of the confidentiality policy and is an insecure flow of information \cite{Hedin2011}. 

Another example of insecure information flow is \emph{implicit flow}:

\begin{lstlisting}[language=ALGOL]
public = false;
if secret then public = true
\end{lstlisting}

In this example the \emph{secret} value affects the control flow and some information is leaked about the \emph{secret} value. Hence this also violates the confidentiality policy. When secret values can affect the control flow there is an implicit flow. An implicit flow is a type of \emph{covert channel} \cite{Sabelfeld2003}.
%Security is equivalent to \emph{secure information flow}

\subsection{Covert channels} The explicit and implicit flows can also be considered as \emph{channels} that signal information \cite{Kashyap2011} \cite{Sabelfeld2003}. \emph{Covert channels} are channels that are not meant to signal information but somehow leaks information \cite{Kashyap2011}. The most prominent covert channels are: 
\begin{itemize}
	\item \emph{Implicit channels} leaks information through the path the program takes in the control flow.
	\item \emph{Termination channels} leaks information by considering if a program terminates.
	\item \emph{Timing channels} leaks information by considering when an action occurs or how much time a program takes.
\end{itemize}

Other channel are \emph{probabilistic channels}, \emph{resource exhaustion channels}, and \emph{power channels}. It is not necessarily all covert channels that are of concern and in the end depends on what is observable by an adversary \cite{Sabelfeld2003}.

\subsection{Noninterference}
Secure information flow can be expressed by the concept of \emph{noninterference}. The notion of noninterference is that someone observing the public input and output of a system should not be able to learn anything about the secret input of the system. If the secret input interferes with the public output then there is information leak. The figure \ref{fig:noninterference} illustrates noninterference \cite{Hedin2011}.  

% The policies defined in section \ref{lattice} are noninterference policies \cite{Sabelfeld2003}. 


\begin{figure}[H]
	\centering
	\includegraphics[width=8cm]{figures/noninterference2.png}
	\caption{ Noninterference \cite{Musard2014}}
	\label{fig:noninterference}
\end{figure}

The figure illustrates that the \emph{L output} (public) should be independent of the \emph{H input} (secret). In other words if a program is executed with fixed public input but with different secret input; then there should not be any changes to the public output \cite{Hedin2011}.


Depending on what an observer is capable of observing; different variations of noninterference can be expressed. Two of such variants are \emph{termination-insensitive} and \emph{termination-sensitive}.


\subparagraph{Termination-insensitive noninterference}

Termination-insensitive noninterference would guarantee that when a program terminates; the program's public output remains unaffected of the secret input. However it is possible to leak information through termination channels. By observing termination; 1 bit leaks can be achieved for each run of the program \cite{Hedin2011}:

\begin{lstlisting}
	if (secret == public) then while (true) do skip done
\end{lstlisting}

If the program does terminate then the observer has learned that the secret is not equal to the public value hence 1 bit of information is leaked. 

%Save the argument of more than 1 bit leak to the discussion.

\subparagraph{Termination-sensitive noninterference}
The alternative is the termination-sensitive noninterference variant. The public output is independent of the secret input. Furthermore if the program is run with secret input \emph{s\textsubscript{1}} and it terminates; then the program run with secret input \emph{s\textsubscript{2}} would terminate as well. Hence if \emph{s\textsubscript{1}} did not terminate then \emph{s\textsubscript{2}} would not either \cite{Hedin2011}.


This variant of noninterference would be achieved by not allowing secret variables as guards in loops and if-else-than statements. This variant would be more restrictive and disallow flows as such \cite{Hedin2011}:

\begin{lstlisting}
while (secret == true) do ... done
\end{lstlisting}

\subsection{Declassification}
Noninterference is a very strict policy and not practical. Consider the classic example of a user logging into a system which violates noninterference. It is unavoidable that a login attempt gives some information away about the password. If the password is incorrect the login fails and partial information is given away. There is no problem with the above and is regarded as secure. Another example is sending encrypted data over an insecure channel; secret input is encrypted and the cipher text would then be send over an insecure channel. However this goes against noninterference since the secret input clearly interferes with public output \cite{Hedin2011}.

Declassifying of information is necessary. Taking some specific information from a higher security class and changing it to a lower security classification is declassification. When declassifying information the following four dimensions needs to be addressed \cite{Sabelfeld2009}:

\begin{itemize}
	\item \emph{What} information should be declassified. We would like to specify what information is released.
	\item \emph{Who} can declassify the information. By specifying exactly who can release information it rules out that someone unspecified can make unintended leaks through declassification.
	\item \emph{Where} the information can flow. The dimension describes which security levels the declassified information may flow to and also where in the code the declassification occurs. 
	\item \emph{When} the declassification occurs. The release of information is only allowed relative to some even e.g. only after a purchase can a software key be released.
\end{itemize}



\subsubsection{Decentralized label model}
\emph{Decentralized Label Model} allows us to define flow policies and address declassification of information in a program. A policy is defined by adding \emph{labels} to a value. A value can hold information for different \emph{principals} called \emph{owners}. A label \emph{L} specifies an \emph{owners} set \emph{owners(L)}. Each owner can allow a list of principals called readers \emph{readers(L,O)} that the information may be released to. \emph{Effective readers} are readers that all owners agree on the information can be released to. An example of a label is \textbf{\{\emph{o\textsubscript{1}}:\emph{r\textsubscript{1},r\textsubscript{2}}; \emph{o\textsubscript{2}}:\emph{r\textsubscript{2},r\textsubscript{3}}\}}; where  \emph{o\textsubscript{1}} and \emph{o\textsubscript{2}} are the different owners with their specified readers \cite{Myers1997}. The example \emph{L} has the following:

\[owners(L) = \{o_1, o_2\}\]
\[readers(L,o_1) = \{r_1, r_2\} \]
\[readers(L,o_2) = \{r_2, r_3\} \]
\[effectiveReaders(L) = \{r_2\} \]

Such labeling makes it possible for each owner to have an independent flow policy and give control of where the information may flow. Declassification is possible if the program detects it is running as the authority of one of the owners \cite{Myers1997} \cite{Myers1998}.


\subsection{Information-flow enforcement}
There exist two general techniques for enforcing secure information flow; \emph{static analysis} through a type system and \emph{dynamic analysis} through a monitor. Both techniques give the assurance of termination-insensitive noninterference \cite{Sabelfeld2010}. The static analysis have the advantage that it does not have the runtime overhead as the dynamic analysis while the dynamic analysis is more permissive \cite{Sabelfeld2010}. 


\subsubsection{Static enforcement}
Enforcement of information-flow through static analysis is done using type systems.
A simple type system is presented and shown in figure \ref{fig:typesystem}. 

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{figures/securitytypesystem.png}
	\caption{ Typing rules \cite{Sabelfeld2010}}
	\label{fig:typesystem}
\end{figure}

We assume that the security lattice has the levels \emph{L} for low (public) and \emph{H} for high (secret). $\Gamma$ denotes a typing environment that takes a variable \emph{x} and maps it to a security level. The function \emph{lev(e)} takes an expression \emph{e} and returns a security level; if \emph{e} holds a high variable then \emph{H} is returned or else \emph{L} is returned. The security level of the context is kept tracked of by the program counter \emph{pc}. The typing judgment for commands is denoted by \emph{pc $\vdash$ c} \cite{Sabelfeld2010}.

The typing rule \emph{pc $\vdash$ x := e} is for assignment; it prevent assignment of a expression that holds a high variable to a low variable \cite{Sabelfeld2010}. Hence the explicit flow would be detected by the type system:

\begin{lstlisting}
low = high
\end{lstlisting}

Furthermore implicit flow are detectable through the program counter \emph{pc}. If there is a high guard then the \emph{pc} has the security level \emph{H} and would expect assignments of high variables hence preventing low assignments \cite{Sabelfeld2010}. The implicit flow would be detected by the typing system as well:

\begin{lstlisting}
if high then low = true else low = false
\end{lstlisting}


\subsubsection{Dynamic enforcement}
Dynamic analysis is provided with \emph{monitors}. Monitoring can only consider one path when running. This has led to the belief that the dynamic approach falls short compared to the static enforcement. However both dynamic enforcement and static enforcement achieve termination-insensitive noninterference hence they give the same security assurance \cite{Sabelfeld2010}. 

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{figures/monitoringrules.png}
	\caption{ Monitoring rules \cite{Sabelfeld2010}}
	\label{fig:monitoring}
\end{figure}

The figure \ref{fig:monitoring} shows monitoring rules for a monitor. Programs generates events and the monitor chooses to accept an event or block it by halting. Security levels are tracked by stack \emph{st} which is called a \emph{monitor configuration} and serves the same purpose as the program counter; keeping track of the current security context.  The monitor can execute following \emph{events}: 

\begin{itemize}
	\item \emph{nop event:} signals a skip and the monitor always this event. It does not change the state of the monitor.
	\item \emph{assignment event a(x,e):} assigns the value of expression \emph{e} to variable \emph{x}. It does not change the state of the monitor but the monitor has the following two conditions:
	\begin{enumerate}
		\item \emph{lev}(\emph{e}) $\sqsubseteq$ $\Gamma(x)$: the expression \emph{e}'s security level is equal or lower than variable \emph{x}'s security level.
		\item \emph{lev}(\emph{st}) $\sqsubseteq$ $\Gamma(x)$: the highest security level in the stack is equal or lower than variable \emph{x}'s security level 
	\end{enumerate} 
	\item \emph{branching event b(e)}: branches on \emph{e} and changes the state of the monitor. The security level of \emph{e} is pushed on the stack.
	\item \emph{event f}: signals are loop or if-else statement has finished evaluating. The security level pushed to the stack \emph{st} would be popped when evaluation is finished.
\end{itemize}

The first condition for the assignment event prevents explicit flows. The second condition prevents implicit flows as such: 

\begin{lstlisting}
if high then low=true else low=false
\end{lstlisting}

The mechanism related to the branching event aids in preventing implicit flows by pushing the security level of \emph{st} to the stack. Now consider the following code: 

\begin{lstlisting}
if high then low=true else skip
\end{lstlisting}

If high is \emph{false} then the code would continue however if high is \emph{true} the execution would be stopped. Hence 1 bit would be leaked and is acceptable in context of termination-insensitive noninterference.

\section{Summary}
The background section introduces security properties necessary for a secure system. Several other security properties are described relevant for a secure messaging system which is relevant for the section \ref{evaluationofmatrix} where Matrix security is evaluated. This section also presented a description of the Signal Protocol necessary for the evaluation as well. Furthermore Matrix and its architecture was described and finally the basic concepts of Information-Flow Control was presented.
